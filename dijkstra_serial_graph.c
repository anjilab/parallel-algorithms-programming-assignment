#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <stdbool.h>
#include <sys/time.h> 
#include <time.h> 
// #include <linux/time.h> // For CLOCK_MONOTONIC

typedef struct Edge {
    int neighbor;
    int weight;
    struct Edge *next;
} Edge;

typedef struct Graph {
    int num_nodes;
    Edge **adj_list; 
} Graph;

Edge* create_edge(int v, int w) {
    Edge* new_edge = (Edge*)malloc(sizeof(Edge));
    if (new_edge == NULL) {
        perror("Memory allocation failed for new edge");
        exit(EXIT_FAILURE);
    }
    new_edge->neighbor = v;
    new_edge->weight = w;
    new_edge->next = NULL;
    return new_edge;
}

Graph* create_graph(int num_nodes) {
    // Return adjancency list representation of the graph: Node 0: -> (2, 3) -> (1, 7) where 0, 2, 1 are nodes and 3,7 are the weights 0 is the source node.
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    if (graph == NULL) {
        perror("Memory allocation failed for graph");
        exit(EXIT_FAILURE);
    }
    graph->num_nodes = num_nodes;
    
    graph->adj_list = (Edge**)malloc(num_nodes * sizeof(Edge*));
    if (graph->adj_list == NULL) {
        perror("Memory allocation failed for adjacency list array");
        free(graph);
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < num_nodes; i++) {
        graph->adj_list[i] = NULL;
    }
    return graph;
}

void add_edge(Graph* graph, int u, int v, int w) {
    // Add edge (u -> v)
    Edge* new_u_v = create_edge(v, w);
    new_u_v->next = graph->adj_list[u];
    graph->adj_list[u] = new_u_v;

    // Add edge (v -> u) to make it undirected
    Edge* new_v_u = create_edge(u, w);
    new_v_u->next = graph->adj_list[v];
    graph->adj_list[v] = new_v_u;
}

int min_distance(int dist[], bool visited[], int num_nodes) {
    int min = INT_MAX, min_index = -1;

    for (int v = 0; v < num_nodes; v++) {
        // Find the minimum distance node that has not been visited
        if (visited[v] == false && dist[v] < min) {
            min = dist[v];
            min_index = v;
        }
    }
    return min_index;
}


void dijkstra_serial(Graph* graph, int src) {
    int num_nodes = graph->num_nodes;
    int *dist = (int*)malloc(num_nodes * sizeof(int));      
    bool *visited = (bool*)malloc(num_nodes * sizeof(bool)); 
    int *parent = (int*)malloc(num_nodes * sizeof(int));    

    if (!dist || !visited || !parent) {
        perror("Memory allocation failed for Dijkstra arrays");
        exit(EXIT_FAILURE);
    }
    for (int i = 0; i < num_nodes; i++) {
        dist[i] = INT_MAX;
        visited[i] = false;
        parent[i] = -1;
    }

    dist[src] = 0;


    for (int count = 0; count < num_nodes - 1; count++) {
        int u = min_distance(dist, visited, num_nodes);

        if (u == -1 || dist[u] == INT_MAX) {
            break; 
        }

        visited[u] = true;

        Edge* current_edge = graph->adj_list[u];
        while (current_edge != NULL) {
            int v = current_edge->neighbor;
            int weight = current_edge->weight;
            if (!visited[v] && dist[u] != INT_MAX && (long long)dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                parent[v] = u;
            }
            current_edge = current_edge->next;
        }
    }

    // Print the final shortest distances
    printf("\n--- Shortest Path Results ---\n");
    printf("Source node: %d\n", src);
    for (int i = 0; i < num_nodes; i++) {
        printf("Node %d: ", i);
        if (dist[i] == INT_MAX) {
            printf("INF\n");
        } else {
            printf("%d\n", dist[i]);
        }
    }

    // Cleanup
    free(dist);
    free(visited);
    free(parent);
}


int main(int argc, char *argv[]) {
    const char *filename = "weighted_graph.txt";
    
    // this is handling error when user do not provide source node.
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <source_node>\n", argv[0]);
        fprintf(stderr, "The program automatically reads graph data from '%s'.\n", filename);
        fprintf(stderr, "Example: ./dijkstra_serial 0\n");
        return EXIT_FAILURE;
    }

    int src_node = atoi(argv[1]);

    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("Error: Could not open input file. Please ensure 'weighted_graph.txt' exists and is generated by graph_generator.c.");
        return EXIT_FAILURE;
    }

    int num_nodes, num_edges;
    if (fscanf(file, "%d %d", &num_nodes, &num_edges) != 2) {
        // Reading hte file in the formatted order
        fprintf(stderr, "Error reading number of nodes and edges from the file.\n");
        fclose(file);
        return EXIT_FAILURE;
    }

    if (src_node < 0 || src_node >= num_nodes) {
        // Ensure the source node is valid or not
        fprintf(stderr, "Error: Source node %d is out of bounds [0, %d].\n", src_node, num_nodes - 1);
        fclose(file);
        return EXIT_FAILURE;
    }

    Graph* graph = create_graph(num_nodes);
    int u, v, w;

    // Read edges (u v w) from the rest of the file
    for (int i = 0; i < num_edges; i++) {
        if (fscanf(file, "%d %d %d", &u, &v, &w) != 3) {
            fprintf(stderr, "Error reading edge %d. File corrupted or ended unexpectedly.\n", i + 1);
            fclose(file);
            return EXIT_FAILURE;
        }
        // Nodes must be within the valid range
        if (u >= num_nodes || v >= num_nodes) {
             fprintf(stderr, "Error: Edge nodes (%d, %d) exceed declared node count (%d).\n", u, v, num_nodes);
             fclose(file);
             return EXIT_FAILURE;
        }
        add_edge(graph, u, v, w);
    }
    fclose(file);

    printf("Successfully loaded graph with %d nodes and %d edges from '%s'.\n", num_nodes, num_edges, filename);
    
    // --- Performance Timing ---
    struct timeval start, end;
    gettimeofday(&start, NULL);
    dijkstra_serial(graph, src_node);
    gettimeofday(&end, NULL);
    double elapsed = (end.tv_sec - start.tv_sec) + (end.tv_usec - start.tv_usec) / 1000000.0;
    
    printf("\n--- Performance ---\n");
    printf("Execution time: %f seconds\n", elapsed);
    printf("----------------------------------------------------------------\nTotal  Execution time: %.3f s\n", elapsed);

    
    // Final graph memory cleanup
    for (int i = 0; i < num_nodes; i++) {
        Edge* current = graph->adj_list[i];
        while (current != NULL) {
            Edge* temp = current;
            current = current->next;
            free(temp);
        }
    }
    free(graph->adj_list);
    free(graph);

    return EXIT_SUCCESS;
}